# 第十章 Agent Loop 运行内核剖析

本章聚焦 Agent Loop 的执行主链：请求如何进入、上下文如何组装、工具如何被调度、结果如何流式返回。理解这条主链，是定位复杂故障与优化执行效率的关键。

在深入代码细节之前，我们需要先建立一个心智模型：**OpenClaw 让任务实现长程运行、可中断、随时恢复的秘密，并不在于大模型有多聪明，而在于其底层直接建立在极其克制的 π (pi) 运行底座之上。**

π 框架几乎什么都不包含，没有复杂的中间件或庞大的抽象层，真正核心的只有三块：
1. **事件（Event）**：系统唯一的语言。所有的工具调用、人工介入、状态变更，都是在一个统一的事件结构里流动，没有任何暗箱操作。
2. **执行器（Executor）**：能力的最小单元。它只负责接收事件、操作状态并返回结果，没有复杂的生命周期管理。
3. **状态机（StateMachine）**：连续性的来源。系统不保存“智能”，只保存状态。状态机明确定义了事件触发的流转规则，形成一个即使没有智能体也能独立运转的闭环。

**OpenClaw 的强大之处在于它的克制：把 Agent 死死限制在“语义决策”这一层，而把长期运行的支撑任务，完全交给 π 的事件循环。** 理解了这种“减少假设、增强稳定”的极简哲学，再去理解本章的各种调度与执行细节，就会如鱼得水。

**本章学习目标**

- 理解入口排队与并发控制机制。
- 掌握提示词组装与系统指令注入方式。
- 理解工具执行与消息回注完整流程。
- 建立流式输出与重试策略的调优方法。

**阅读建议**

阅读时建议同时画出本地系统的执行链路图，并在每个环节标注可观测指标与失败处理策略。
